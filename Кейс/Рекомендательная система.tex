\documentclass[a4paper,14pt]{article}
\input{AESh.sty}
\input{DM.sty}
\usepackage{caption}
\usepackage{pdfpages}

\begin{document}
\begin{center}
{\LARGE \bf Рекомендательная система \\}
{\Large \copyright Ракитин Виталий Павлович, \\}
{\Large МГУ им. М.В.Ломоносова, 5 курс, механико-математический факультет.\\
15 сентября 2016\\}
\end{center}
\tableofcontents
\section{Цель }
Проектировка рекомендательной системы.

\section{Постановка задачи }
{\it \bf Что мы имеем?}
\begin{enumerate}
\item Множество пользователей $u = u(\Psi) \in U(\Psi)= \{u_1(\Psi),u_2(\Psi),\dots\}$, где $\Psi$ "--- множество параметров, характеризующих данного пользователя:
\begin{itemize}
\item Пол;
\item Возраст;
\item Социальный статус, социальная группа;
\item Регион, где он проживает;
\item Увлечения, интересы;
\item \dots
\end{itemize}
\item Множество объектов  $obj \in \Omega = \{obj_1,obj_2,\dots\}$;
\item Множество действий над объектами $ r_{ij} = (i = u, j = obj) \in \Lambda = \{r_{11}, r_{12}, \dots\}$\\ (оценка, покупка, просмотр и тд "--- {\bf рейтинг}).
\end{enumerate} 
\begin{Zam} 
Из множества действий можно так же генерировать элементы множества $\Psi$\\ (пользователи оптимисты, пользователи со схожими препочтениями \dots)
\end{Zam}

{\it \bf Что мы хотим получить?}

Предсказать предпочтения конкретного пользователя $u \in U$, а так же составить для него {\bf персональные рекомендации} на основе этих предпочтений.

%\section{Решение задачи}
%Составим матрицу <<предпочтений>> следующим образом:
%\begin{itemize}
%\item Строки "--- пользователи $U$;
%\item Столбцы "--- объекты $\Omega$;
%\item На пересечении "--- результат действия $\Lambda$.
%\end{itemize}
%\begin{center}
%\begin{tabular}[t]{|c|c|c|c|c|c|}
%\hline
%    & $obj_1$ & $obj_2$ & $obj_3$ & $obj_4$ & $obj_5$  \\
%\hline  
%$u_1$ & 4 & 5  & 3 & ? &  2  \\  
%hline 
%$u_2$ & 2  & ? & 1 & 4 & 2  \\ 
%\hline
%$u_3$ & 3  & 7 & 5 & 1 & 3  \\ 
% \hline
%\end{tabular}
%\end{center}

%В тех позициях, где у нас есть конкретное значение действия, подразумевается, что пользователь уже~проявил <<явную>> активность, а пропущенные значения нам необходимо <<предсказать>>, то есть найти $\ol r_{ij}$
\section{Сбор информации о пользователе }
Чем больше информации мы будем иметь "--- тем больше вероятность получить точное предсказание.
\begin{itemize}\label{inform}
\item При регистраиции предложить заполнить анекту с минимальной информацией о пользователе;
\item Предложить синхронизацию социальных сетей;
\item Отслеживать параметры <<друзей>>, а так же их предпочтения;
\item Следить за <<явной>> активностью пользователя (покупки, лайки);
\item Фиксировать <<неявную>> активность (какие страницы посещает, на каких задерживается).
\end{itemize}

\section{Введение связей между объектами} 
{\bf Идея:} Нет смысла предлагать пользователям товар, который он уже преобрёл (оценил) или строго аналогичный, однако можно рекомендовать <<родственные>> объекты, например
\begin{itemize}
\item {\it Если {\bf u} только преобрёл iPhone 6s, то нет смысла предлагать ему телефоны, но можно предложить аксессуары};
\item {\it Бессмысленно предлагать читать пользователю одну и ту же запись, опубликованную в разных местах, но можно предложить записи схожей тематики.}
\item \dots
\end{itemize}

Для каждого объекта введём 2 параметра:
\begin{enumerate}
\item {\bf Тип;}
\item {\bf Родство}.
\end{enumerate}

Одинаковые (аналогичные) объекты нумеруются одинаковым {\bf типом}, <<близкие>> "--- {\bf родством}. Родство может задаваться как {\bf <<базовое>>} (аксессуары, товары одного производителя/автора, с помощью хэш-тегов и тд), а так же его можно определять из соображения, какие объекты обычно оцениваются (преобретаются) вместе. После этого проведём кластеризацию всех объектов по степени родства.

\section{Способы хранения данных}
\subsection{Объекты}\label{obj}
\begin{center}
\begin{tabular}[t]{|c|c|c|c|c|c|c|c|c|c|}
\hline
 Объект($\Omega$) & origID & Keys & TopObj & Тип &\multicolumn{3}{|c|}{Родство} & Time & Click \\\cline{6-8}
   &  && && subID & similarity &  TopObj & & \\
\hline  
 &  &  & &&  &  & &&\\ 
\end{tabular}
\end{center}
\begin{itemize}
\item {\bf origID} "--- кодовый номер объекта;
\item {\bf Keys }"--- ключевые слова, хэш-теги, параметры, по которым определяется степень родства с другими объектами;
\item {\bf Click }"--- количество обращений;
\item {\bf Time }"--- время последнего обращения к объекту;
\item {\bf TopObj} "--- популярность данного объекта:
\[TopObj = function(Time,Click)\]
\item {\bf Родство} "--- связь c другими объектами;
\item {\bf Similarity} "--- степень родства объектов;
\item {\bf subID} "--- кодовый номер родственного объекта \\(отсортированы по степени родства, в случае одинаковой --- по Top);
\end{itemize}

\subsection{Top-популярных объектов}\label{pop}
Отдельно храним список объектов, отсортированный по популярности, на случай абсолютно холодного старта.
\begin{center}
\begin{tabular}[t]{|c|c|c|c|c|c|c|}
\hline
 origID & Click \\
\hline  
 &   \\ 
\end{tabular}
\end{center}
\begin{itemize}
\item {\bf origID} "--- кодовый номер объекта;
\item {\bf Click} "--- количество обращений;
\end{itemize}

\subsection{Пользователи} \label{users}
\begin{center}
\begin{tabular}[t]{|c|c|c|c|c|c|c|}
\hline
 User (U) & uID & $\mathrm{origID_i}$ & $\mathrm{r_{ui}}$ & \dots Параметры($\Psi$) \dots & ObjTopID \\
\hline  
 &  &  & & &  \\ 
\end{tabular}
\end{center}
\begin{itemize}
\item {\bf uID} "--- уникальный номер пользователя;
\item {\bf $\mathrm{origID_i}$} "--- все объекты, с которыми пользователь взаимодействовал; 
\item {\bf $\mathrm{r_{ui}}$} "--- рейтинг данных объектов;
\item {\bf Параметры} "--- все параметры которые мы смогли узнать о нашем пользователе;
\item {\bf ObjTopID} "--- Top-10 наиболее релевантных рекомендаций для данного пользователя;
\end{itemize}

\subsection{База сходства пользователей}
\begin{center}
\begin{tabular}[t]{|c|c|c|c|c|c|}
\hline
    & $u_1$ & $u_2$ & $u_3$ & $u_4$ & \dots  \\
\hline  
$u_1$ &  &  &  &  &   \\  
 \hline
\dots &  &  &  &  &   \\ 
 \hline
\end{tabular}
\end{center}
\begin{itemize}
\item По строкам и столбцам распределены все пользователи конкретного кластера;
\item На пересечении "--- степени их похожести $sim(u_i,u_j) = \frac{1}{1+dH\left(u_i,u_j\right)}$ (через растояние Хэмминга).
\end{itemize}
\subsection{База предпочтений}
Для каждого отдельно взятого пользовательского кластера строим таблицу следующего вида:
\begin{center}
\begin{tabular}[t]{|c|c|c|c|c|c|}
\hline
    & $obj_1$ & $obj_2$ & $obj_3$ & $obj_4$ & \dots  \\
\hline  
$middle$ & 4 &  & 5 & 6 &   \\  
\hline  
$u_1$ & 3 &  & 7 & 9 &   \\  
\hline 
$u_2$ & 6 & 1  & 8 & 3 &    \\ 
 \hline
$u_3$ &  &  &  2&  &   \\ 
 \hline
\dots &  &  &  &  &   \\ 
 \hline
\end{tabular}
\end{center}
\begin{itemize}
\item По строкам распределены все пользователи данного кластера;
\item По столбцам "--- список всех объектов, с которыми взаимодействуют данные пользователи, а так же по N первых родственных объектов другого типа по степени родства.
\item На пересечении расположены {\bf рейтинги}, полученные от соответствующих пользователей соответствующими объектами($\Lambda$). На местах пропуска впишем {\bf оценку рейтинга} (наше <<предсказание>>).  
\item В строке {\bf middle} указаны средние оценки объектов по всем пользователям кластера.
\end{itemize}

\subsection{База кластеров пользователей}
\begin{center}
\begin{tabular}[t]{|c|c|c|c|c|c|c|}
\hline
  Номер кластера  & uIDs & Центроид  \\
\hline  
& & \\  

\end{tabular}
\end{center}
\begin{itemize}
\item uIDs "--- списки польователей в данном кластере;
\end{itemize}

\section{Роботы}
\begin{Def}
Роботы "--- программы-демоны, обеспечивающие работу системы.
\end{Def}
\begin{enumerate}
\item {\bf Кластеризатор пользователей} "--- проходит по базе (\ref{users}), случайным образом выбирая начальные центры кластеров. Сохраняем $J$ и $\Theta$ (ошибка и центроиды) для минимального $J$. Так как алгорит {\bf k-means} является локальным, то проводим данную операцию большое количество раз;
\item {\bf Редактор базы кластеров} "--- запускается, когда  {\bf кластеризатор Users} нашёл разбиение c меньшей ошибкой;
%\item{\bf Редактор базы пользователей  } "--- запускается, когда  {\bf редактор базы кластеров} изменил список кластеров и их состав. Изменяет номер текущего кластера для каждого пользователя; 
\item{\bf Редактор базы пользователей сходства } "--- запускается, когда  {\bf редактор базы кластеров} изменил список кластеров и их состав;
\item {\bf Редактор базы объектов} "--- добавляет новые объекты в базу  (\ref{obj}), пересчитывает Родство объетов, определяет тип;
\item {\bf Информатор} "--- при выполнении пользователями действий над объектами увеличивает {\bf Click} и {\bf TopObj}, изменяет {\bf Time}, добавляет в базу (\ref{users}) информацию о взаимодействии объектов, повышает количество {\bf Click} в (\ref{pop});
\item {\bf Сортировщик Top} "--- регулярно сортирует базу популярных объектов;
\item {\bf Редактор базы рекомендаций} "--- запускаетя при изменении базы сходства пользователей или базы объектов,  высчитывает Top-10 рекомендаций для каждого пользователя;
\item{\bf Редактор базы пользователей  } "--- получает от {\bf редактора базы рекомендаций} Top-10 и заносит его~в~базу (\ref{users});
\item {\bf Мусорщик} "--- следит за {\bf Time} в списке объектов и удаляет устаревшие, а так же все упоминания о них в других базах. 
\end{enumerate}

\section{Построение рекомендаций}
\subsection{Кластеризация пользователей } 
{\bf Идея:} похожим пользователям обычно нравятся похожие объекты, поэтому на основе пункта (\ref{inform}) кластеризуем множество $U$.

\begin{itemize}
\item Метрика "--- расстояние Хэмминга, а именно $dH(x,y)$ "--- количество различных компонент в {\bf x} и {\bf y};
\item Применим метод кластеризации {\bf k-means};
\item Количество кластеров будем определять исходя из количества пользоваталей;
\item Сохраним центроиды наших кластеров в множество $\Theta = \{c_1, c_2, \dots\}$.
\item Мера ошибки
\[
{\ol J} = \sum\limits_{n=1}^N \sum\limits_{k=1}^k r_{nk} d(x_n,\mu_k),
\]
где $d(x_n,\mu_k)$ "--- функция расстояния, 
$\mu_k$ "--- один из объектов кластера.
\end{itemize}
\subsection{Предсказание}
Рассмотрим 2 подхода построения предсказания. Оба запроса будут выполняться на разных серверах. В качестве результирующего будем брать тот, который приходит быстрее, либо среднее арифметическое результатов.
\subsubsection{Пользовательский}
\[
\ol r_{ui} = r_{u} + \frac{\sum\limits_{u\in U_i} sim(u,v)\cdot(r_{vi} - r_v)}{\sum\limits_{u\in U_i} sim(u,v)}
\]
\begin{itemize}
\item $r_u$ "--- средняя оценка нашим пользователем всех объектом;
\end{itemize}
\subsubsection{Объектный}
\[
\ol r_{ui} = r_{i} + \frac{\sum\limits_{j\in I_u} sim(i,j)\cdot(r_{ui} - r_j)}{\sum\limits_{j\in I_u} sim(i,j)}
\]
\begin{itemize}
\item $r_j$ "--- средняя оценка пользователями одного кластера данного объекта;
\end{itemize}

\subsection{Конечный алгоритм подбора рекомендаций}
Рассмотрим несколько вариантов восприятия пользователя в системе:
\begin{enumerate}
\item {\it Пользователь существует в базе, информация по нему собрана:}
\begin{itemize}
\item {\it Существует список Top-10 рекомендаций} "--- рекомендуем первые объекты из топа;
\item {\it Списка рекомендаций нет} "--- возьмём выборку пользователей из того же кластера из базы предпочтений, на их основе сделаем предсказания. Отсортируем предсказания по рейтингу и предложим Top;
\end{itemize} 
\item Пользователя нет в базе:
\begin{itemize}
\item {\it Можно собрать <<неявную>> информацию} "--- определим ближайшую группу из базы кластеров, возьмём выборку пользователей из этого кластера из базы предпочтений, на их основе сделаем предсказания. Отсортируем предсказания по рейтингу и предложим Top;
\item {\it Холодный старт } "--- предложить Top-популярных;
\end{itemize} 
\end{enumerate}

\end{document}